:hardbreaks:

= Spring Hibernate Multitenant Example

== Multitenancy in Hibernate
* SCHEMA
  - MultiTenantConnectionProvider 를 구현해야 한다.
* DATABASE
  - MultiTenantConnectionProvider 를 구현해야 한다.
* DISCRIMINATOR
  - 지원안함

=== MultiTenantConnectionProvider
- 테넌트마다 지정된 DB 커넥션정보를 제공
- hibernate.multi_tenant_connection_provider 프로퍼티로 지정
- 지정하지 않으면 DataSourceBasedMultiTenantConnectionProviderImpl를 사용

=== CurrentTenantIdentifierResolver
- tenant 식별하기
- hibernate.tenant_identifier_resolver 로 지정

== 구현
Tenant.java
- Tenant DataBase 정보 저장을 위한 Entity
[source,java]
----
@Entity
@Getter
@ToString
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Tenant {
  @Id
  @Column(length = 50)
  private String id;

  private String dbName;

  private String dbAddress;

  private String dbUsername;

  private String dbPassword;

  @Transient
  public String getJdbcUrl() {
    return String.format("jdbc:mariadb://%s/%s?createDatabaseIfNotExist=true", dbAddress, dbName);
  }

}

----


MasterDatabaseConfig.java
[source,java]
----
public class MasterDatabaseConfig {

  @Bean
  @Primary
  @ConfigurationProperties("multitenant.master.datasource")
  public DataSourceProperties masterDataSourceProperties() {
    return new DataSourceProperties();
  }

  @Bean
  @Primary
  @ConfigurationProperties("multitenant.master.datasource.dbcp2")
  public BasicDataSource masterDataSource() {
    return masterDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource.class).build();
  }


  @Bean
  @Primary
  public LocalContainerEntityManagerFactoryBean masterEntityManagerFactory(EntityManagerFactoryBuilder builder) {
    return builder.dataSource(masterDataSource())
        .packages("com.example.multitenant.master")
        .persistenceUnit("master")
        .build();
  }


  @Bean
  @Primary
  public PlatformTransactionManager masterTransactionManager(@Qualifier("masterEntityManagerFactory") EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
  }

}
----

DataSourceBasedMultiTenantConnectionProviderImpl.java
[source,java]
----
@Configuration
@Slf4j
public class DataSourceBasedMultiTenantConnectionProviderImpl extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl {

  private static final long serialVersionUID = -6837240859738111430L;

  private TenantRepository tenantRepository;

  private BasicDataSource masterDataSource;

  @Autowired
  public void setTenantRepository(TenantRepository tenantRepository) {
    this.tenantRepository = tenantRepository;
  }

  @Resource(name = "masterDataSource")
  public void setBasicDataSource(BasicDataSource masterDataSource) {
    this.masterDataSource = masterDataSource;
  }

  @Override
  protected DataSource selectAnyDataSource() {
    return masterDataSource;
  }

  private DataSource createDataSource(Tenant source) {
    BasicDataSource dataSource = new BasicDataSource();
    dataSource.setUsername(source.getDbUsername());
    dataSource.setPassword(source.getDbPassword());
    dataSource.setDriverClassName("org.mariadb.jdbc.Driver");
    dataSource.setUrl(source.getJdbcUrl());
    return dataSource;
  }

  @Override
  protected DataSource selectDataSource(String tenantId) {
    Tenant tenantDataSource = tenantRepository.findById(tenantId).orElseThrow();
    return createDataSource(tenantDataSource);
  }
}
----

CurrentTenantIdentifierResolverImpl.java
[source,java]
----
public class CurrentTenantIdentifierResolverImpl implements CurrentTenantIdentifierResolver {

  private static final String DEFAULT_TENANT_ID = "default";

  @Override
  public String resolveCurrentTenantIdentifier() {
    String tenant = TenantContextHolder.getTenantId();
    return StringUtils.hasText(tenant) ? tenant : DEFAULT_TENANT_ID;
  }

  @Override
  public boolean validateExistingCurrentSessions() {
    return true;
  }
}
----

TenantDatabaseConfig.java
[source,java]
----
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = {"com.example.multitenant.tenant"},
    entityManagerFactoryRef = "tenantEntityManagerFactory",
    transactionManagerRef = "tenantTransactionManager")
public class TenantDatabaseConfig {
  public static final String PERSISTENCE_UNIT_NAME = "tenant";

  @Bean
  @ConditionalOnBean(name = "masterEntityManagerFactory")
  public MultiTenantConnectionProvider multiTenantConnectionProvider() {
    return new DataSourceBasedMultiTenantConnectionProviderImpl();
  }

  @Bean
  public CurrentTenantIdentifierResolver currentTenantIdentifierResolver() {
    return new CurrentTenantIdentifierResolverImpl();
  }


  @Bean
  public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory(
      @Qualifier("multiTenantConnectionProvider") MultiTenantConnectionProvider connectionProvider,
      @Qualifier("currentTenantIdentifierResolver") CurrentTenantIdentifierResolver tenantIdentifierResolver) {
    LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
    entityManagerFactoryBean.setPackagesToScan("com.example.multitenant.tenant");
    entityManagerFactoryBean.setPersistenceUnitName(PERSISTENCE_UNIT_NAME);
    entityManagerFactoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
    Map<String, Object> properties = new HashMap<>();
    properties.put(Environment.MULTI_TENANT, MultiTenancyStrategy.DATABASE);
    properties.put(Environment.MULTI_TENANT_CONNECTION_PROVIDER, connectionProvider);
    properties.put(Environment.MULTI_TENANT_IDENTIFIER_RESOLVER, tenantIdentifierResolver);
    properties.put(Environment.DIALECT, "org.hibernate.dialect.MySQL5Dialect");
    properties.put(Environment.HBM2DDL_AUTO, Action.UPDATE);
    properties.put(Environment.PHYSICAL_NAMING_STRATEGY, SpringPhysicalNamingStrategy.class);
    entityManagerFactoryBean.setJpaPropertyMap(properties);
    return entityManagerFactoryBean;
  }

  @Bean
  public PlatformTransactionManager tenantTransactionManager(@Qualifier("tenantEntityManagerFactory") EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
  }
}
----

=== 요청 처리하기
요청시 헤더에서 tenant를 식별
TenantInterceptor.java
[souce,java]
----
public class TenantInterceptor implements HandlerInterceptor {

  public static final String HEADER_X_TENANT_ID = "X-TENANT-ID";

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    String tenantId = request.getHeader(HEADER_X_TENANT_ID);
    if (StringUtils.hasText(tenantId)) {
      TenantContextHolder.setTenantId(tenantId);
    }
    return true;
  }

  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
      throws Exception {
    TenantContextHolder.clear();
  }
}
----

TenantContextHolder.java
[source,java]
----
public class TenantContextHolder {

  private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();

  public static void setTenantId(String tenantId) {
    contextHolder.set(tenantId);
  }

  public static String getTenantId() {
    return contextHolder.get();
  }

  public static void clear() {
    contextHolder.remove();
  }
}

----



서버시작시 DataSourceBasedMultiTenantConnectionProviderImpl.selectAnyDataSource() 를 두번(?) 호출한다. 이때 Schema 가 JPA 설정이 create/update 일 경우 schema 가 생성된다.
클라이언트 요청에 의해 selectDataSource(tenantIdentifier)를 호출할때에는 Schema 가 생성되지 않는다.

## Issues
고객 가입/등록시 Database/Schema 생성 기능 - 외부에서 DDL을 실행해야 함

## References
https://docs.jboss.org/hibernate/orm/5.5/userguide/html_single/Hibernate_User_Guide.html#multitenacy
https://dzone.com/articles/dynamic-multi-tenancy-using-java-spring-boot-sprin

