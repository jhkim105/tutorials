:hardbreaks:

= Spring Hibernate Multitenant Example

== Multitenancy in Hibernate
* SCHEMA
  - MultiTenantConnectionProvider 를 구현해야 한다.
* DATABASE
  - MultiTenantConnectionProvider 를 구현해야 한다.
* DISCRIMINATOR
  - 지원안함

=== MultiTenantConnectionProvider
- 테넌트마다 지정된 DB 커넥션정보를 제공
- hibernate.multi_tenant_connection_provider 프로퍼티로 지정
- 지정하지 않으면 DataSourceBasedMultiTenantConnectionProviderImpl를 사용

=== CurrentTenantIdentifierResolver
- tenant 식별하기
- hibernate.tenant_identifier_resolver 로 지정

== 구현
Tenant.java
- Tenant DataBase 정보 저장을 위한 Entity
[source,java]
----
@Entity
@Getter
@ToString
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Tenant {
  @Id
  @Column(length = 50)
  private String id;

  private String dbName;

  private String dbAddress;

  private String dbUsername;

  private String dbPassword;

  @Transient
  public String getJdbcUrl() {
    return String.format("jdbc:mariadb://%s/%s?createDatabaseIfNotExist=true", dbAddress, dbName);
  }

}

----


MasterDatabaseConfig.java
[source,java]
----
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = "com.example.multitenant.master",
    entityManagerFactoryRef = "masterEntityManagerFactory",
    transactionManagerRef = "masterTransactionManager"
)
public class MasterDatabaseConfig {

  @Bean
  @Primary
  @ConfigurationProperties("multitenant.master.datasource")
  public DataSourceProperties masterDataSourceProperties() {
    return new DataSourceProperties();
  }

  @Bean
  @Primary
  @ConfigurationProperties("multitenant.master.datasource.dbcp2")
  public BasicDataSource masterDataSource() {
    return masterDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource.class).build();
  }


  @Bean
  @Primary
  public LocalContainerEntityManagerFactoryBean masterEntityManagerFactory(EntityManagerFactoryBuilder builder) {
    return builder.dataSource(masterDataSource())
        .packages("com.example.multitenant.master")
        .persistenceUnit("master")
        .build();
  }


  @Bean
  @Primary
  public PlatformTransactionManager masterTransactionManager(@Qualifier("masterEntityManagerFactory") EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
  }

}
----

DataSourceBasedMultiTenantConnectionProviderImpl.java
[source,java]
----
@Component
@Slf4j
public class DataSourceBasedMultiTenantConnectionProviderImpl extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl {

  private static final long serialVersionUID = -6837240859738111430L;

  private TenantRepository tenantRepository;

  private BasicDataSource masterDataSource;

  @Autowired
  public void setTenantRepository(TenantRepository tenantRepository) {
    this.tenantRepository = tenantRepository;
  }

  @Resource(name = "masterDataSource")
  public void setBasicDataSource(BasicDataSource masterDataSource) {
    this.masterDataSource = masterDataSource;
  }

  @Override
  protected DataSource selectAnyDataSource() {
    return masterDataSource;
  }

  private DataSource createDataSource(Tenant source) {
    BasicDataSource dataSource = new BasicDataSource();
    dataSource.setUsername(source.getDbUsername());
    dataSource.setPassword(source.getDbPassword());
    dataSource.setDriverClassName("org.mariadb.jdbc.Driver");
    dataSource.setUrl(source.getJdbcUrl());
    return dataSource;
  }

  @Override
  protected DataSource selectDataSource(String tenantId) {
    Tenant tenantDataSource = tenantRepository.findById(tenantId).orElseThrow();
    return createDataSource(tenantDataSource);
  }
}
----

CurrentTenantIdentifierResolverImpl.java
[source,java]
----
public class CurrentTenantIdentifierResolverImpl implements CurrentTenantIdentifierResolver {

  private static final String DEFAULT_TENANT_ID = "default";

  @Override
  public String resolveCurrentTenantIdentifier() {
    String tenant = TenantContextHolder.getTenantId();
    return StringUtils.hasText(tenant) ? tenant : DEFAULT_TENANT_ID;
  }

  @Override
  public boolean validateExistingCurrentSessions() {
    return true;
  }
}
----

TenantDatabaseConfig.java
[source,java]
----
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = {"com.example.multitenant.tenant"},
    entityManagerFactoryRef = "tenantEntityManagerFactory",
    transactionManagerRef = "tenantTransactionManager")
public class TenantDatabaseConfig {
  public static final String PERSISTENCE_UNIT_NAME = "tenant";

  @Bean
  @ConditionalOnBean(name = "masterEntityManagerFactory")
  public MultiTenantConnectionProvider multiTenantConnectionProvider() {
    return new DataSourceBasedMultiTenantConnectionProviderImpl();
  }

  @Bean
  public CurrentTenantIdentifierResolver currentTenantIdentifierResolver() {
    return new CurrentTenantIdentifierResolverImpl();
  }


  @Bean
  public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory(
      @Qualifier("multiTenantConnectionProvider") MultiTenantConnectionProvider connectionProvider,
      @Qualifier("currentTenantIdentifierResolver") CurrentTenantIdentifierResolver tenantIdentifierResolver) {
    LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
    entityManagerFactoryBean.setPackagesToScan("com.example.multitenant.tenant");
    entityManagerFactoryBean.setPersistenceUnitName(PERSISTENCE_UNIT_NAME);
    entityManagerFactoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
    Map<String, Object> properties = new HashMap<>();
    properties.put(Environment.MULTI_TENANT, MultiTenancyStrategy.DATABASE);
    properties.put(Environment.MULTI_TENANT_CONNECTION_PROVIDER, connectionProvider);
    properties.put(Environment.MULTI_TENANT_IDENTIFIER_RESOLVER, tenantIdentifierResolver);
    properties.put(Environment.DIALECT, "org.hibernate.dialect.MySQL5Dialect");
    properties.put(Environment.HBM2DDL_AUTO, Action.UPDATE);
    properties.put(Environment.PHYSICAL_NAMING_STRATEGY, SpringPhysicalNamingStrategy.class);
    entityManagerFactoryBean.setJpaPropertyMap(properties);
    return entityManagerFactoryBean;
  }

  @Bean
  public PlatformTransactionManager tenantTransactionManager(@Qualifier("tenantEntityManagerFactory") EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
  }
}
----

=== 요청 처리하기
요청시 헤더에서 tenant를 식별
TenantInterceptor.java
[souce,java]
----
public class TenantInterceptor implements HandlerInterceptor {

  public static final String HEADER_X_TENANT_ID = "X-TENANT-ID";

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    String tenantId = request.getHeader(HEADER_X_TENANT_ID);
    if (StringUtils.hasText(tenantId)) {
      TenantContextHolder.setTenantId(tenantId);
    }
    return true;
  }

  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
      throws Exception {
    TenantContextHolder.clear();
  }
}
----

TenantContextHolder.java
[source,java]
----
public class TenantContextHolder {

  private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();

  public static void setTenantId(String tenantId) {
    contextHolder.set(tenantId);
  }

  public static String getTenantId() {
    return contextHolder.get();
  }

  public static void clear() {
    contextHolder.remove();
  }
}

----



서버시작시 DataSourceBasedMultiTenantConnectionProviderImpl.selectAnyDataSource() 를 두번(?) 호출한다. 이때 Schema 가 JPA 설정이 create/update 일 경우 schema 가 생성된다.
클라이언트 요청에 의해 selectDataSource(tenantIdentifier)를 호출할때에는 Schema 가 생성되지 않는다.

=== Schema 동적으로 생성하기
고객 가입/등록시 Database/Schema 생성 기능
https://github.com/jhkim105/tutorials/blob/master/persistence/spring-data-jpa/src/main/java/jhkim105/tutorials/spring/data/jpa/utils/HibernateUtils.java

=== Tenant DataSource Caching Using Guava Cache
[source, xml]
----
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>27.0.1-jre</version>
    </dependency>
----
최신버전 (27.1-jre 이상) 을 사용하면 build error. Maven build 또는 java -jar 로 실행시에는 문제 없으나, 인텔리제이에서 테스트케이스 실행 또는 Application 을 실행하면 발생함.
----
java: package com.google.common.cache does not exist'
----

[source, java]
----
  private LoadingCache<String, DataSource> tenantDataSources;

  @Override
  protected DataSource selectDataSource(String tenantId) {
    if (DEFAULT_TENANT_ID.equals(tenantId)) {
      log.info("MasterDataSource selected");
      return dataSource;
    }
    try {
      BasicDataSource tenantDataSource = (BasicDataSource)tenantDataSources.get(tenantId);
      log.info("Tenant DataSource selected. url: [{}], cacheSize: [{}]", tenantDataSource.getUrl(), tenantDataSources.size());
      return tenantDataSource;
    } catch (ExecutionException e) {
      throw new IllegalStateException("Failed to load DataSource for tenant: " + tenantId);
    }
  }

  @PostConstruct
  void createDataSourceCache() {
    tenantDataSources = CacheBuilder.newBuilder()
        .maximumSize(tenantDataSourceCacheProperties.getMaxSize())
        .expireAfterAccess(tenantDataSourceCacheProperties.getExpireMinutes(), TimeUnit.MINUTES)
        .removalListener((RemovalListener<String, DataSource>) removal -> {
          BasicDataSource ds = (BasicDataSource)removal.getValue();
          try {
            ds.close();
            log.info("Closed datasource(url:[{}]).", ds.getUrl());
          } catch (SQLException e) {
            log.warn(e.toString());
          }

        })
        .build(new CacheLoader<>() {
          public DataSource load(String key) {
            Tenant tenant = tenantRepository.findById(key)
                .orElseThrow(() -> new IllegalStateException(String.format("Tenant not exists. id([%s])", key)));
            return createDataSource(tenant);
          }
        });

  }
----
만료된 캐시는 자동으로 삭제되지 않음. 해당 캐시를 접근하거나, maximum size 에 도달했을때 삭제 됨.
https://github.com/google/guava/wiki/CachesExplained#when-does-cleanup-happen
주기적으로 캐시를 정리하고 싶으면 주기적(ScheduledExecutorService)으로 Cache.cleanup() 을 호출해야 한다.
[source, java]
----

  @Scheduled(fixedRate = 10_000)
  public void cleanUpCache() {
    this.tenantDataSources.cleanUp();
  }

----

== References
https://docs.jboss.org/hibernate/orm/5.5/userguide/html_single/Hibernate_User_Guide.html#multitenacy
https://dzone.com/articles/dynamic-multi-tenancy-using-java-spring-boot-sprin

